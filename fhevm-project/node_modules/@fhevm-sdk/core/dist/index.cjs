'use strict';

var ethers = require('ethers');
var node = require('@zama-fhe/relayer-sdk/node');

// src/errors.ts
var SDKErrorCode = /* @__PURE__ */ ((SDKErrorCode2) => {
  SDKErrorCode2["NOT_INITIALIZED"] = "NOT_INITIALIZED";
  SDKErrorCode2["ALREADY_INITIALIZED"] = "ALREADY_INITIALIZED";
  SDKErrorCode2["INVALID_CONFIG"] = "INVALID_CONFIG";
  SDKErrorCode2["ENCRYPTION_FAILED"] = "ENCRYPTION_FAILED";
  SDKErrorCode2["DECRYPTION_FAILED"] = "DECRYPTION_FAILED";
  SDKErrorCode2["TRANSACTION_FAILED"] = "TRANSACTION_FAILED";
  SDKErrorCode2["TIMEOUT"] = "TIMEOUT";
  SDKErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  SDKErrorCode2["INVALID_SCHEMA"] = "INVALID_SCHEMA";
  SDKErrorCode2["MISSING_SIGNER"] = "MISSING_SIGNER";
  return SDKErrorCode2;
})(SDKErrorCode || {});
var SDKError = class _SDKError extends Error {
  code;
  cause;
  constructor(code, message, cause) {
    super(message);
    this.code = code;
    this.cause = cause;
    this.name = "SDKError";
    Object.setPrototypeOf(this, _SDKError.prototype);
  }
  static notInitialized() {
    return new _SDKError(
      "NOT_INITIALIZED" /* NOT_INITIALIZED */,
      "FHEVM SDK not initialized. Call initFHEVM() first."
    );
  }
  static alreadyInitialized() {
    return new _SDKError(
      "ALREADY_INITIALIZED" /* ALREADY_INITIALIZED */,
      "FHEVM SDK already initialized."
    );
  }
  static invalidConfig(details) {
    return new _SDKError("INVALID_CONFIG" /* INVALID_CONFIG */, `Invalid configuration: ${details}`);
  }
  static encryptionFailed(cause) {
    return new _SDKError("ENCRYPTION_FAILED" /* ENCRYPTION_FAILED */, "Failed to encrypt input", cause);
  }
  static decryptionFailed(cause) {
    return new _SDKError("DECRYPTION_FAILED" /* DECRYPTION_FAILED */, "Failed to decrypt data", cause);
  }
  static transactionFailed(cause) {
    return new _SDKError("TRANSACTION_FAILED" /* TRANSACTION_FAILED */, "Transaction execution failed", cause);
  }
  static timeout(operation, timeoutMs) {
    return new _SDKError(
      "TIMEOUT" /* TIMEOUT */,
      `Operation '${operation}' timed out after ${timeoutMs}ms`
    );
  }
  static invalidSchema(details) {
    return new _SDKError("INVALID_SCHEMA" /* INVALID_SCHEMA */, `Invalid schema: ${details}`);
  }
  static missingSigner() {
    return new _SDKError("MISSING_SIGNER" /* MISSING_SIGNER */, "Signer is required for this operation");
  }
};

// src/config.ts
var NETWORK_PRESETS = {
  localhost: {
    aclAddress: "0x0000000000000000000000000000000000000000",
    kmsVerifierAddress: "0x0000000000000000000000000000000000000000",
    inputVerifierAddress: "0x0000000000000000000000000000000000000000",
    verifyingContractAddress: "0x0000000000000000000000000000000000000000",
    gatewayUrl: "http://localhost:8545",
    gatewayChainId: 31337
  },
  sepolia: {
    // Real Sepolia FHEVM testnet addresses from Zama
    aclAddress: "0x687820221192C5B662b25367F70076A37bc79b6c",
    kmsVerifierAddress: "0x1364cBBf2cDF5032C47d8226a6f6FBD2AFCDacAC",
    inputVerifierAddress: "0xbc91f3daD1A5F19F8390c400196e58073B6a0BC4",
    verifyingContractAddress: "0x7048C39f048125eDa9d678AEbaDfB22F7900a29F",
    gatewayUrl: "https://relayer.testnet.zama.cloud",
    gatewayChainId: 55815
  },
  mainnet: {
    aclAddress: "0x0000000000000000000000000000000000000000",
    kmsVerifierAddress: "0x0000000000000000000000000000000000000000",
    inputVerifierAddress: "0x0000000000000000000000000000000000000000",
    verifyingContractAddress: "0x0000000000000000000000000000000000000000",
    gatewayUrl: "https://gateway.mainnet.zama.ai",
    gatewayChainId: 1
  },
  custom: null
  // User must provide all config values
};
function resolveNetworkPresets(network) {
  const preset = NETWORK_PRESETS[network];
  if (!preset) {
    throw new Error(
      `Network preset '${network}' requires custom configuration. Please provide aclAddress, kmsVerifierAddress, and gatewayUrl.`
    );
  }
  return preset;
}
var context = null;
async function initFHEVM(config) {
  if (context?.initialized) {
    throw SDKError.alreadyInitialized();
  }
  try {
    const presets = config.network !== "custom" ? resolveNetworkPresets(config.network) : null;
    const resolvedConfig = {
      network: config.network,
      aclAddress: config.aclAddress ?? presets?.aclAddress ?? "",
      kmsVerifierAddress: config.kmsVerifierAddress ?? presets?.kmsVerifierAddress ?? "",
      inputVerifierAddress: config.inputVerifierAddress ?? presets?.inputVerifierAddress ?? "",
      verifyingContractAddress: config.verifyingContractAddress ?? presets?.verifyingContractAddress ?? "",
      gatewayUrl: config.gatewayUrl ?? presets?.gatewayUrl ?? "",
      gatewayChainId: config.gatewayChainId ?? presets?.gatewayChainId ?? 0,
      provider: config.provider
    };
    if (!resolvedConfig.aclAddress || !resolvedConfig.kmsVerifierAddress || !resolvedConfig.inputVerifierAddress || !resolvedConfig.verifyingContractAddress || !resolvedConfig.gatewayUrl || !resolvedConfig.gatewayChainId) {
      throw SDKError.invalidConfig("Missing required configuration fields");
    }
    let networkUrl;
    if (resolvedConfig.provider) {
      networkUrl = void 0;
    } else if (resolvedConfig.network === "sepolia") {
      networkUrl = "https://eth-sepolia.g.alchemy.com/v2/demo";
    } else if (resolvedConfig.network === "localhost") {
      networkUrl = "http://localhost:8545";
    }
    const fhevmInstance = await node.createInstance({
      aclContractAddress: resolvedConfig.aclAddress,
      kmsContractAddress: resolvedConfig.kmsVerifierAddress,
      inputVerifierContractAddress: resolvedConfig.inputVerifierAddress,
      verifyingContractAddressInputVerification: resolvedConfig.verifyingContractAddress,
      verifyingContractAddressDecryption: resolvedConfig.verifyingContractAddress,
      gatewayChainId: resolvedConfig.gatewayChainId,
      relayerUrl: resolvedConfig.gatewayUrl,
      network: networkUrl,
      chainId: resolvedConfig.network === "sepolia" ? 11155111 : void 0
    });
    context = {
      config: resolvedConfig,
      initialized: true,
      fhevmInstance
    };
  } catch (error) {
    if (error instanceof SDKError) throw error;
    throw SDKError.invalidConfig(String(error));
  }
}
function getFHEVM() {
  if (!context?.initialized) {
    throw SDKError.notInitialized();
  }
  return context;
}
async function encryptInput(params) {
  const ctx = getFHEVM();
  try {
    const encryptedInput = ctx.fhevmInstance.createEncryptedInput(
      params.contract,
      params.user
    );
    for (const [key, type] of Object.entries(params.schema)) {
      const value = params.values[key];
      switch (type) {
        case "uint8":
          encryptedInput.add8(BigInt(value));
          break;
        case "uint16":
          encryptedInput.add16(BigInt(value));
          break;
        case "uint32":
          encryptedInput.add32(BigInt(value));
          break;
        case "uint64":
          encryptedInput.add64(BigInt(value));
          break;
        case "address":
          encryptedInput.addAddress(value);
          break;
        case "bytes":
          if (typeof value === "boolean") {
            encryptedInput.addBool(value);
          } else {
            throw SDKError.encryptionFailed(`Unsupported bytes value type: ${typeof value}`);
          }
          break;
        default:
          throw SDKError.encryptionFailed(`Unsupported encryption type: ${type}`);
      }
    }
    const { handles, inputProof } = await encryptedInput.encrypt();
    const flatHandles = handles.reduce((acc, h) => {
      acc.push(...Array.from(h));
      return acc;
    }, []);
    const data = "0x" + Buffer.from(flatHandles).toString("hex");
    const proof = "0x" + Buffer.from(inputProof).toString("hex");
    return {
      data,
      proof,
      meta: {
        contract: params.contract,
        user: params.user,
        schema: params.schema
      }
    };
  } catch (error) {
    throw SDKError.encryptionFailed(error);
  }
}
async function executeEncrypted(params) {
  getFHEVM();
  try {
    const contract = new ethers.Contract(params.contract, params.abi, params.signer);
    const contractFunction = contract.getFunction(params.functionName);
    const tx = await contractFunction(
      params.encrypted.data,
      params.encrypted.proof,
      params.overrides ?? {}
    );
    const receipt = await tx.wait();
    return {
      hash: tx.hash,
      receipt
    };
  } catch (error) {
    throw SDKError.transactionFailed(error);
  }
}
async function waitForDecryption(params) {
  getFHEVM();
  try {
    const contract = new ethers.Contract(params.contract, [], params.provider);
    const timeout = params.timeoutMs ?? 3e4;
    return await Promise.race([
      new Promise((resolve) => {
        const filter = contract.filters[params.event]?.(params.filter) ?? params.event;
        contract.once(filter, (...args) => {
          const eventData = args[args.length - 1];
          resolve(eventData);
        });
      }),
      new Promise((_, reject) => {
        setTimeout(() => {
          reject(SDKError.timeout("decryption", timeout));
        }, timeout);
      })
    ]);
  } catch (error) {
    throw SDKError.decryptionFailed(error);
  }
}
async function userDecrypt(params) {
  const ctx = getFHEVM();
  try {
    const { publicKey, privateKey } = ctx.fhevmInstance.generateKeypair();
    const eip712 = ctx.fhevmInstance.createEIP712(
      publicKey,
      [params.ciphertext],
      // contract addresses
      Math.floor(Date.now() / 1e3),
      // start timestamp
      1
      // duration in days
    );
    const types = eip712.types.UserDecryptRequestVerification;
    if (!types) {
      throw SDKError.decryptionFailed("Missing EIP-712 types");
    }
    const signature = await params.signer.signTypedData(
      eip712.domain,
      { UserDecryptRequestVerification: types },
      eip712.message
    );
    const userAddress = await params.signer.getAddress();
    const results = await ctx.fhevmInstance.userDecrypt(
      [{ handle: params.ciphertext, contractAddress: params.ciphertext }],
      privateKey,
      publicKey,
      signature,
      [params.ciphertext],
      userAddress,
      Math.floor(Date.now() / 1e3),
      1
    );
    return String(results[params.ciphertext]);
  } catch (error) {
    throw SDKError.decryptionFailed(error);
  }
}
async function publicDecrypt(params) {
  const ctx = getFHEVM();
  try {
    const results = await ctx.fhevmInstance.publicDecrypt([params.ciphertext]);
    return String(results[params.ciphertext]);
  } catch (error) {
    throw SDKError.decryptionFailed(error);
  }
}
function resetFHEVM() {
  context = null;
}

exports.NETWORK_PRESETS = NETWORK_PRESETS;
exports.SDKError = SDKError;
exports.SDKErrorCode = SDKErrorCode;
exports.encryptInput = encryptInput;
exports.executeEncrypted = executeEncrypted;
exports.getFHEVM = getFHEVM;
exports.initFHEVM = initFHEVM;
exports.publicDecrypt = publicDecrypt;
exports.resetFHEVM = resetFHEVM;
exports.resolveNetworkPresets = resolveNetworkPresets;
exports.userDecrypt = userDecrypt;
exports.waitForDecryption = waitForDecryption;

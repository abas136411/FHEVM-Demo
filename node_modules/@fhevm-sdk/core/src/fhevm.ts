import type {
  FHEVMConfig,
  FHEVMContext,
  EncryptInputParams,
  EncryptedInput,
  ExecuteEncryptedParams,
  WaitForDecryptionParams,
  UserDecryptParams,
  PublicDecryptParams,
} from './types';
import { SDKError } from './errors';
import { resolveNetworkPresets } from './config';
import { Contract } from 'ethers';
import { createInstance } from '@zama-fhe/relayer-sdk/node';
import type { FhevmInstance } from '@zama-fhe/relayer-sdk/node';

let context: FHEVMContext | null = null;

/**
 * Initialize the FHEVM SDK with configuration
 * Loads TFHE/WASM via Zama SDK and stores context
 */
export async function initFHEVM(config: FHEVMConfig): Promise<void> {
  if (context?.initialized) {
    throw SDKError.alreadyInitialized();
  }

  try {
    // Resolve network presets if not using custom
    const presets = config.network !== 'custom' ? resolveNetworkPresets(config.network) : null;

    const resolvedConfig = {
      network: config.network,
      aclAddress: config.aclAddress ?? presets?.aclAddress ?? '',
      kmsVerifierAddress: config.kmsVerifierAddress ?? presets?.kmsVerifierAddress ?? '',
      inputVerifierAddress: config.inputVerifierAddress ?? presets?.inputVerifierAddress ?? '',
      verifyingContractAddress: config.verifyingContractAddress ?? presets?.verifyingContractAddress ?? '',
      gatewayUrl: config.gatewayUrl ?? presets?.gatewayUrl ?? '',
      gatewayChainId: config.gatewayChainId ?? presets?.gatewayChainId ?? 0,
      provider: config.provider,
    } as FHEVMContext['config'];

    // Validate required fields
    if (
      !resolvedConfig.aclAddress ||
      !resolvedConfig.kmsVerifierAddress ||
      !resolvedConfig.inputVerifierAddress ||
      !resolvedConfig.verifyingContractAddress ||
      !resolvedConfig.gatewayUrl ||
      !resolvedConfig.gatewayChainId
    ) {
      throw SDKError.invalidConfig('Missing required configuration fields');
    }

    // Determine network URL
    let networkUrl: string | undefined;
    if (resolvedConfig.provider) {
      // Provider given - Zama SDK will use it
      networkUrl = undefined;
    } else if (resolvedConfig.network === 'sepolia') {
      // Use Alchemy's public demo endpoint for Sepolia
      networkUrl = 'https://eth-sepolia.g.alchemy.com/v2/demo';
    } else if (resolvedConfig.network === 'localhost') {
      networkUrl = 'http://localhost:8545';
    }

    // Create REAL FHEVM instance using Zama SDK
    const fhevmInstance: FhevmInstance = await createInstance({
      aclContractAddress: resolvedConfig.aclAddress,
      kmsContractAddress: resolvedConfig.kmsVerifierAddress,
      inputVerifierContractAddress: resolvedConfig.inputVerifierAddress,
      verifyingContractAddressInputVerification: resolvedConfig.verifyingContractAddress,
      verifyingContractAddressDecryption: resolvedConfig.verifyingContractAddress,
      gatewayChainId: resolvedConfig.gatewayChainId,
      relayerUrl: resolvedConfig.gatewayUrl,
      network: networkUrl as any,
      chainId: resolvedConfig.network === 'sepolia' ? 11155111 : undefined,
    });

    context = {
      config: resolvedConfig,
      initialized: true,
      fhevmInstance,
    };
  } catch (error) {
    if (error instanceof SDKError) throw error;
    throw SDKError.invalidConfig(String(error));
  }
}

/**
 * Get the current FHEVM context
 * @throws {SDKError} if SDK is not initialized
 */
export function getFHEVM(): FHEVMContext {
  if (!context?.initialized) {
    throw SDKError.notInitialized();
  }
  return context;
}

/**
 * Encrypt input values according to schema using REAL Zama SDK
 */
export async function encryptInput(
  params: EncryptInputParams
): Promise<EncryptedInput> {
  const ctx = getFHEVM();

  try {
    // Create encrypted input using REAL Zama SDK
    const encryptedInput = ctx.fhevmInstance.createEncryptedInput(
      params.contract,
      params.user
    );

    // Add each value according to schema type
    for (const [key, type] of Object.entries(params.schema)) {
      const value = params.values[key];

      switch (type) {
        case 'uint8':
          encryptedInput.add8(BigInt(value as number));
          break;
        case 'uint16':
          encryptedInput.add16(BigInt(value as number));
          break;
        case 'uint32':
          encryptedInput.add32(BigInt(value as number));
          break;
        case 'uint64':
          encryptedInput.add64(BigInt(value as number));
          break;
        case 'address':
          encryptedInput.addAddress(value as string);
          break;
        case 'bytes':
          // For boolean values encoded as bytes
          if (typeof value === 'boolean') {
            encryptedInput.addBool(value);
          } else {
            throw SDKError.encryptionFailed(`Unsupported bytes value type: ${typeof value}`);
          }
          break;
        default:
          throw SDKError.encryptionFailed(`Unsupported encryption type: ${type}`);
      }
    }

    // Encrypt and get handles + proof
    const { handles, inputProof } = await encryptedInput.encrypt();

    // Convert to hex strings
    // Flatten handles array and convert to Buffer
    const flatHandles = handles.reduce<number[]>((acc, h) => {
      acc.push(...Array.from(h));
      return acc;
    }, []);
    const data = '0x' + Buffer.from(flatHandles).toString('hex');
    const proof = '0x' + Buffer.from(inputProof).toString('hex');

    return {
      data,
      proof,
      meta: {
        contract: params.contract,
        user: params.user,
        schema: params.schema,
      },
    };
  } catch (error) {
    throw SDKError.encryptionFailed(error);
  }
}

/**
 * Execute encrypted transaction
 * Uses ethers v6 to send tx with encrypted input
 */
export async function executeEncrypted(
  params: ExecuteEncryptedParams
): Promise<{ hash: string; receipt: unknown }> {
  getFHEVM();

  try {
    const contract = new Contract(params.contract, params.abi, params.signer);
    const contractFunction = contract.getFunction(params.functionName);

    const tx = await contractFunction(
      params.encrypted.data,
      params.encrypted.proof,
      params.overrides ?? {}
    );

    const receipt = await tx.wait();

    return {
      hash: tx.hash,
      receipt,
    };
  } catch (error) {
    throw SDKError.transactionFailed(error);
  }
}

/**
 * Wait for decryption event
 */
export async function waitForDecryption(
  params: WaitForDecryptionParams
): Promise<unknown> {
  getFHEVM();

  try {
    const contract = new Contract(params.contract, [], params.provider);
    const timeout = params.timeoutMs ?? 30000;

    return await Promise.race([
      new Promise((resolve) => {
        const filter = contract.filters[params.event]?.(params.filter) ?? params.event;
        contract.once(filter, (...args) => {
          // Last arg is the event object, previous args are event parameters
          const eventData = args[args.length - 1];
          resolve(eventData);
        });
      }),
      new Promise((_, reject) => {
        setTimeout(() => {
          reject(SDKError.timeout('decryption', timeout));
        }, timeout);
      }),
    ]);
  } catch (error) {
    throw SDKError.decryptionFailed(error);
  }
}

/**
 * User decrypt with EIP-712 signature
 */
export async function userDecrypt(params: UserDecryptParams): Promise<string> {
  const ctx = getFHEVM();

  try {
    // Generate keypair for this decryption request
    const { publicKey, privateKey } = ctx.fhevmInstance.generateKeypair();

    // Create EIP-712 structure
    const eip712 = ctx.fhevmInstance.createEIP712(
      publicKey,
      [params.ciphertext], // contract addresses
      Math.floor(Date.now() / 1000), // start timestamp
      1 // duration in days
    );

    // Sign with user's wallet
    const types = eip712.types.UserDecryptRequestVerification;
    if (!types) {
      throw SDKError.decryptionFailed('Missing EIP-712 types');
    }
    const signature = await params.signer.signTypedData(
      eip712.domain,
      { UserDecryptRequestVerification: types },
      eip712.message
    );

    // Decrypt using user's private key
    const userAddress = await params.signer.getAddress();
    const results = await ctx.fhevmInstance.userDecrypt(
      [{ handle: params.ciphertext, contractAddress: params.ciphertext }],
      privateKey,
      publicKey,
      signature,
      [params.ciphertext],
      userAddress,
      Math.floor(Date.now() / 1000),
      1
    );

    return String(results[params.ciphertext]);
  } catch (error) {
    throw SDKError.decryptionFailed(error);
  }
}

/**
 * Public decrypt via relayer
 */
export async function publicDecrypt(params: PublicDecryptParams): Promise<string> {
  const ctx = getFHEVM();

  try {
    const results = await ctx.fhevmInstance.publicDecrypt([params.ciphertext]);
    return String(results[params.ciphertext]);
  } catch (error) {
    throw SDKError.decryptionFailed(error);
  }
}

/**
 * Reset context (mainly for testing)
 */
export function resetFHEVM(): void {
  context = null;
}
